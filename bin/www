#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app').app;
var debug = require('debug')('xerisure:server');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

// Old? Pre 2025Q2 ie < 6-6-25?
//var io = app.io;
//io.attach( server );
//console.log(io);
// IO v4.8.n
const { Server } = require('socket.io');
const io = new Server(server);




/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}





// var sport; // SerialPort global???
// app.locals.sport = sport;

var Gateway = require('../models/Gateway.js').Gateway;

var utils = require('../lib/utils.js');

var SerialPort = require('serialport').SerialPort;
var portName = utils.getFirstTtyUsbDeviceSync();

var sp = null;
var xbee_api = require('xbee-api');
var XBCs = xbee_api.constants;
var xbeeAPI = new xbee_api.XBeeAPI({ api_mode: 1 });

async function openSerialPortWithRetry(options, maxRetries = 10, delayMs = 2000) {
  let attempt = 0;
  while (attempt < maxRetries) {
    try {
      // Log the serial port open attempt and attempt number
      console.log(`Attempting to open serial port (attempt ${attempt + 1} of ${maxRetries}): ${options.path}`);
      pushLog(`Attempting to open serial port (attempt ${attempt + 1} of ${maxRetries}): ${options.path}`);

      let sp = new SerialPort(options);
      await new Promise((resolve, reject) => {
        sp.on('open', () => {
          // Additional logging/output logic here
          const m = `Serial port opened (event): ${sp.path}`;
          console.log(m);
          pushLog(m); // This will emit to all /gateway clients

          // You can also emit a custom event if needed
          io.of('/gateway').emit('serialport_status', {
            status: 'open',
            path: sp.path,
            timestamp: new Date().toISOString()
          });

          resolve();
        });
        sp.on('error', (err) => {
          // Additional logging/output logic here
          const m = `Serial port error (event): ${err.message}`;
          console.error(m);
          pushLog(m); // This will emit to all /gateway clients

          // You can also emit a custom event if needed
          io.of('/gateway').emit('serialport_status', {
            status: 'error',
            error: err.message,
            path: sp.path,
            timestamp: new Date().toISOString()
          });

          reject(err);
        });
      });
      console.log('Serial port opened:', options.path);
      return sp;
    } catch (err) {
      console.error(`Serial port open failed (attempt ${attempt + 1}):`, err.message);
      attempt++;
      await utils.sleep(delayMs);
    }
  }
  throw new Error('Failed to open serial port after retries');
}

// Usage:
(async () => {
  try {
    sp = await openSerialPortWithRetry(
      { path: portName, baudRate: 9600, autoOpen: true }
    );
    // Now that sp is ready, set up the pipes:
    sp.pipe(xbeeAPI.parser);
    xbeeAPI.builder.pipe(sp);

    // If you have any other sp-dependent setup, put it here.
    // For example, event listeners:
    // sp.on('open', ...);
    // sp.on('error', ...);

  } catch (err) {
    console.error('Could not open serial port:', err.message);
    // Optionally, exit or continue without serial port
  }
})();


// Now call it on app launch
//setupAndOpenSerialPort(portName);



// var sp = new SerialPort( 
//   '/dev/ttyUSB1', //portName,
//   {
//     baudRate: 9600,
//     autoOpen: false 
//   }
// );

// sp.on('open', function() {
//   var m = `www top level: port.on(open): serial port open ... portName: ${portName}`;
//   console.log(m);
//   io.emit('data', `<br>> [www top level] ${m}`);
// });


// sp.on('error', function(err) {
//   var m = `SerialPort port Error: ' ${err.message} ${err.stack}`;
//   console.log(m);
//   io.emit('data', `<br>> ${m}`)

// });

// sp.open();


//
// We now try binding to xbee API...
/*
sp.on('data', function(data) {
  //io.of('/gateway').emit('serialdataRx', rdat);
  //console.log('serial data received: ', rdat);

  //socket.emit('data', "<br>Socket ID: " + socket.id + "<br>");
  //io.emit('data', "<br>Socket ID: " + socket.id + "<br>");
  //console.log(socket.id);
  //socket.emit('data', "<br>Raw in rcvd: " + data.toString().replace("\r","<br>"));
  io.emit('data', "<br>Raw in rcvd: " + data.toString().replace("\r","<br>"));
  // was replace with <br> // lines terminated with 0x0d
  // or replace with " " (using "" creates a problem)

  // API type data
  // TODO Complete API packet parsing implementation and DRY/Encap etc.
  var s = " ";
  var bufAsString = " ";
  for ( var i = 0; i < data.length; i++ ) {
    s = "0x" + ('0' + (data[i] & 0xFF).toString(16)).slice(-2);
    bufAsString += " " + s;
    if ( s == '0x7e' ) {
      // these three were socket.emit within the Gateway code
      io.emit('data', "<br>API Packet start rcvd: Flush to screen and reset the prior API Packet hex and ASCII keepers: <br>");
      io.emit('data', "apiPacketString: " + apiPacketString + "<br>");
      io.emit('data', "apiStringTrans:  " + apiStringTrans + "<br>Done flushes.<br>");
      apiPacketString = s;
      apiStringTrans = '----';
    } else {
      apiPacketString += " " + s;
      if ( parseInt(s) > 32 && parseInt(s) < 127 ) {
        apiStringTrans += " " + "   " + String.fromCharCode(parseInt(s));
      } else {
        apiStringTrans += " " + s;
      }
    }
  }
  // these two were socket.emit within the old gateway code
  io.emit('data', "<br>Current bufAsString: " + bufAsString + "<br>");
  io.emit('data', "<br>Current apiPacketString: " + apiPacketString + "<br>");

  stringBuffer += data.toString();              // Accumulate between data received until buffer is dumped, etc.

  // Alert: Until complete API is implemented, we'll be one buffer short so request one extra frame etc.

  console.log("port data received:");
  console.log(data);

  app.locals.apiPacketString = apiPacketString;

});
*/ // because we now try binding / piping via xbeeAPI
//
//



const backendEvents = require('../lib/utils.js').ServerSideEmitter;


// TEST NOTE
// HOWTO TEST
// Launch the app aka 
// pm2 restart www && pm2 logs www
// watch for expected launch and some expected pin get functionality
// then ctrl-C to exit pm2 logs
// and on the command line:
// sudo usbreset 0403:6015
// which will reset the ttyUSB* device 
// pm2 logs www (again if you want to monitor)
// Now click again something to get pin status - this should trigger the serial port error 
// which should trigger this event and a re-open of the serial port after the timeout on 
// asyncWriteRead in gateway

backendEvents.on('portReopen', function() {
  if ( sp ) {
    if ( sp.isOpen ) {
      sp.close();
    }
  }
  reopenSerialPort();
});

// Back to singleton for now - oy.
// Let's see if we can fire this up
// and replace our early custom api.
var xbee_api = require('xbee-api');
var XBCs = xbee_api.constants;

var xbeeAPI = new xbee_api.XBeeAPI({
  api_mode: 1
});

// Moved to async function above
// sp.pipe(xbeeAPI.parser);
// xbeeAPI.builder.pipe(sp);

// omit the example sp.on open fcn

xbeeAPI.parser.on( "data", function(frame) {

  console.log(`(RX) www xb parser on data: ${JSON.stringify(frame)}`);
  console.log(`rxd frame command data: ${JSON.stringify(frame.commandData)}`);
  var msgType = `xbee-data-frameType${frame.type.toString(16)}`;
  console.log(msgType);
  //io.emit(msgType, frame);
  backendEvents.emit(msgType, frame);

  //io.emit('xbee-data', frame); // if we wanted to process on the client side - but we don't
  // var data = frame.commandData.data;
  // for ( var i = 0; i < data.length; i++ ) {
  //   s = "0x" + ('0' + (data[i] & 0xFF).toString(16)).slice(-2);
  //   bufAsString += " " + s;
  // }
  //console.log(s);

  // Msg q would be great here

  // 

});





/**
 * \brief   thisLilLogOfMine
 * @param m 
 */
let pushLog = function (m, socket) {
  console.log(m);
  if ( socket ) {
    socket.emit('data', `<br>> ${m}`);
  } else {
    // Interestingly, yes, the namespace works but without it, the message does not get 
    // through to the gateway path (ie io.emit() doesn't do it)
    io.of('/gateway').emit('data', `<br>> ${m}`);
  }
}





var reopenSerialPort = async function() {
  portName = utils.getFirstTtyUsbDeviceSync();
  //await setupAndOpenSerialPort(portName);

  sp = new SerialPort(
    portName,
    {
      baudRate: 9600,     // TODO extract to env  
      autoOpen: false     // TODO maybe extract to env or const top level
    }
  );

  // Right so yeah - don't want to repeat self here - but ... couldn't yet 
  // get a non-repeat yourself method to work .... working on it eventually 
  // in the meantime ...

  sp.on('open', function() {
    var m = `www top level: port.on(open): serial port open ... portName: ${portName}`;
    pushLog(m);
  });

  sp.on('error', function(err) {
    var m = `SerialPort port Error: ' ${err.message} ${err.stack}`;
    pushLog(m);
  });

  await sp.open();
  sp.pipe(xbeeAPI.parser);
  xbeeAPI.builder.pipe(sp);

  // This actually takes too long to open and so will not happen here without some delay
  setTimeout( function() {
    if ( sp.isOpen ) {
      var m = `sp re-opened with path ${sp.path} and xbeeAPI <=> sp pipes re-established.`;
      pushLog(m); // without socket parameters should give io.emit
    } else {
      var m = `Problem: after trying to re-open serial port with update first path ${portName}, sp is still not open.`;
      pushLog(m);
    }
  }, 2000); // 2 seconds should be long enough 

}




//var Gateway = require('../models/gatewayMod').Gateway;

io.of('/gateway').on('connection', async function (socket) {
  
  console.log('Socket connected');
  var addy = socket.conn.remoteAddress;
  console.log(`with IP: ${addy}`);
  console.log("socket.id: " + socket.id);
  console.log(' %s sockets connected', io.engine.clientsCount);
  socket.emit('connected', true);

  // TODO send serial port connected status to the client and 
  // client should show in some useful UI

  if ( sp.readable ) {
    console.log(`sp.readable: ${sp.readable}`);       // 
    console.log(`serial port is open: ${sp.isOpen}`);
  }

  if ( !sp ) {
    var m = `sp is nothing - that's a problem.`;
    pushLog(m, socket);
  }

  // TODO - do we want to check how many clients connected and 
  // try the re-open conditionally?
  if ( !sp.isOpen ) {
    var m = `sp is not open - trying to re-open, using first matching ttyUSB dev path...`;
    pushLog(m, socket);
    await reopenSerialPort();
    console.log(`${sp.path}`);
  }

  socket.on('disconnect', function () {
      //console.log("Server got socket disconnect for: " + socket.id);
      //console.log(' %s sockets connected', io.engine.clientsCount);
      var m = `Server got socket disconnect for: ${socket.id}. ${io.engine.clientsCount} sockets connected.`;
      pushLog(m, socket);
  });

  // socket.on('writeserialdata', function(wdat) {
  //   //sp.flush(); // TODO 
  //   console.log('www top level: got serial dat write request');
  //   sp.write(wdat, function(err, res) {
  //     console.log('writeserialdata ', wdat);
  //   });
  // });

  // nope
  //io.of('/gateway').emit('wdata', "test from within top");

  //Gateway.setup_serial_port_and_socket_messaging(io, socket);

  

  // Do you miss ajax and post?
  // Or are socket(s) awesome here?
  socket.on('client_set_destination_mac_id', function(macid) {
      console.log("Server socket received client_set_destination_mac_id of " + macid);
      Gateway.set_destination_radio_mac_id(socket, macid);
  });

  socket.on('client_set_digital_io', function(macid, pin, state) {
      console.log("Server socket received client_set_digital_io of "
          + macid + " for pin " + pin
          + " to state " + state);
      Gateway.set_digital_io(socket, macid, pin, state, xbeeAPI);
  });

  socket.on('client_get_digital_io', function(macid, pin, state) {
      console.log("Server socket received client_get_digital_io of "
          + macid + " for pin " + pin
          + " to state " + state);
      Gateway.get_digital_io(socket, macid, pin, xbeeAPI);
  });

  socket.on('client_get_gateway_radio_serial_link_destination_mac_id_info', function() {
      console.log('Server socket received client_get_gateway_radio_serial_link_destination_mac_id_info');
      Gateway.get_gateway_xbee_dest_mac(socket);
  });

  socket.on('client_get_gateway_radio_mac_id_info', function() {
      console.log('Server socket received client_get_gateway_radio_mac_id_info');
      Gateway.get_gateway_xbee_mac(socket);
  });

  socket.on('client_get_remote_radio_dios', function(macid) {
      console.log('Server socket received client_get_remote_radio_dios');
      Gateway.get_remote_radio_dios(socket, macid);
  });

  socket.on('client_do_node_discover', function() {
      console.log('Server socket received client_do_node_discover');
      Gateway.do_node_discover(socket);
  });

  socket.on('client_get_gateway_radio_dios', function() {
      console.log('Server socket received client_get_gateway_radio_dios');
      Gateway.get_gateway_radio_dios(socket);
  });

  socket.on('client_get_db_radio_mac_ids', function() {
      console.log('Server socket received client_get_db_radio_mac_ids');
      Gateway.get_db_radio_mac_ids(socket);
  });

  socket.on('client_pop_db_radio_mac_ids', function() {
      console.log('Server socket received client_pop_db_radio_mac_ids');
      Gateway.pop_db_radio_mac_ids(socket);
  });

  socket.on('client_set_digital_io_with_timed_reset', function( macid, pin, timedstate, durationMinutes) {
      console.log('Server socket receive client_set_digital_io_with_timed_reset');
      Gateway.set_digital_io_with_timed_reset(socket, macid, pin, timedstate, durationMinutes);
  });

  socket.on('client_set_digital_io_with_timed_reset_known_state_values', function( macid, pin, timedstate, durationMinutes, offstate) {
      console.log('Server socket receive client_set_digital_io_with_timed_reset_known_state_values');
      console.log('durationMinutes: ' + durationMinutes);
      if ( !durationMinutes || !parseInt(durationMinutes) || parseInt(durationMinutes) < 0 || parseInt(durationMinutes) > 2880 ) { // TODO max config minutes watering length
        console.log('durationMinutes: missing or incorrect parameter - returning');
        socket.emit('data', "<br>> Returning without doing anyway - duration parameter missing");
        return;
      }
      socket.emit('data', `<br><br>> Run Water Circ: Turn pin On, wait ${durationMinutes} minute(s), and then turn Off`);
      Gateway.set_digital_io_with_timed_reset_known_state_values(socket, macid, pin, timedstate, durationMinutes, offstate, xbeeAPI);
  });

  // Not implemented
  socket.on('client_store_nd_radios_in_db', function(radios) {
      console.log('Server socket received client_store_nd_radios_in_db');
      Gateway.store_nd_radios_in_db(socket, radios);
  });

  socket.on('client_load_radio_data', function(macId) {
    console.log('Server socket received client_load_radio_data');
    Gateway.load_radio_data(socket, macId);
  });

  socket.on('get_serialport_status', function () {
    console.log("get_serialport_status");
    if (sp && sp.isOpen) {
      pushLog(`Serial port is open: ${sp.path}`, socket);
      socket.emit('serialport_status', { status: 'open', path: sp.path });
    } else {
      pushLog("Serial port is not open", socket);
      socket.emit('serialport_status', { status: 'not_open' });
    }
  });

  Gateway.pop_db_radio_mac_ids(socket);
  

});
